<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>p5 Tilt-Scale Letters in Two Words</title>
    <script src="https://unpkg.com/p5@1.6.0/lib/p5.min.js"></script>
    <script src="https://unpkg.com/p5@1.6.0/lib/addons/p5.dom.min.js"></script>
    <style>
      body { margin:0; overflow:hidden; }
      #motionBtn {
        position: absolute;
        top: 1rem; left: 50%;
        transform: translateX(-50%);
        padding: .5rem 1rem;
        font-size: 1rem;
        z-index: 10;
      }
    </style>
  </head>
  <body>
    <button id="motionBtn">Enable Motion Effects</button>
    <script>
      // === CONFIG ===
      let words         = ['if','no'];
      let baseFontSize  = 114;
      let maxScale      = 5;    // letter grows up to this
      let minScale      = 0.7;  // others shrink down to this
      let smoothing     = 0.1;

      // Flatten letters into array with row info
      let letters = [];
      words.forEach((w, row) => {
        for (let c of w) {
          letters.push({ char: c, row, baseScale: 1, targetScale: 1 });
        }
      });

      // Motion / permission logic (unchanged)
      let permissionGranted = false;
      const deadZone        = 1,
            smoothingFactor = 0.15,
            updateInterval  = 50,
            maxTilt         = 45;  // degrees

      let lastScale   = 1,
          lastTiltLR  = 0,
          lastUpdate  = 0;

      function requestMotionPermission() {
        if (typeof DeviceOrientationEvent !== 'undefined'
         && typeof DeviceOrientationEvent.requestPermission === 'function') {
          DeviceOrientationEvent.requestPermission()
            .then(r => {
              if (r === 'granted') enableMotion();
              else              console.warn('Motion permission denied');
            })
            .catch(console.error);
        } else {
          enableMotion();
        }
      }

      function enableMotion() {
        permissionGranted = true;
        select('#motionBtn').hide();
        window.addEventListener('deviceorientation', handleOrientation);
      }

      function handleOrientation(evt) {
        if (!permissionGranted) return;
        let tilt = evt.gamma;
        if (abs(tilt) < deadZone) return;

        let now = Date.now();
        if (now - lastUpdate < updateInterval) return;
        lastUpdate = now;
        lastTiltLR = tilt;

        // map |tilt| to [1..maxScale]
        let t = constrain(abs(tilt) / maxTilt, 0, 1);
        let raw = 1 + t * (maxScale - 1);
        lastScale += smoothingFactor * (raw - lastScale);
      }

      function setup() {
        createCanvas(windowWidth, windowHeight);
        textSize(baseFontSize);
        textAlign(LEFT, BASELINE);
        textStyle(BOLD);
        textLeading(baseFontSize * 1.2);
        select('#motionBtn').mousePressed(requestMotionPermission);
      }

      function draw() {
        background(255);

        // 1) decide which letter index to “hover” based on tilt sign and magnitude
        let total = letters.length; // 4
        let idx = floor(map(lastTiltLR, -maxTilt, maxTilt, 0, total));
        idx = constrain(idx, 0, total - 1);

        // 2) set targetScale on each letter
        letters.forEach((L, i) => {
          if (i === idx) {
            L.targetScale = lastScale;
          } else {
            // inverse shrink
            L.targetScale = map(
              lastScale,
              1, maxScale,
              1, minScale,
              true
            );
          }
        });

        // 3) lerp current toward target
        letters.forEach(L => {
          L.baseScale = lerp(L.baseScale, L.targetScale, smoothing);
        });

        // 4) draw letters in column, centered
        push();
          translate(width / 2, height / 2);
          // For each row, compute starting x offset so row is centered
          for (let row = 0; row < words.length; row++) {
            // collect indices for this row
            let rowLetters = letters.filter(L => L.row === row);
            // sum widths
            let totalW = rowLetters.reduce((sum, L) =>
              sum + textWidth(L.char) * L.baseScale, 0);
            // start x so this row is centered
            let x = -totalW / 2;
            let y = (row - (words.length - 1)/2) * textLeading();
            // draw
            rowLetters.forEach(L => {
              push();
                translate(x, y);
                scale(L.baseScale, 1);
                text(L.char, 0, 0);
              pop();
              x += textWidth(L.char) * L.baseScale;
            });
          }
        pop();
      }

      function windowResized() {
        resizeCanvas(windowWidth, windowHeight);
      }
    </script>
  </body>
</html>
